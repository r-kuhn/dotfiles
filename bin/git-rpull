#! /bin/bash
SUBDIRECTORY_OK='Yes'
OPTIONS_KEEPDASHDASH=
OPTIONS_SPEC="\
git rpull [--prune] [-q|--quiet]

Recursively pull the upstream branches of the current branch. For
example, if I have: master tracking origin/master, foo tracking
master, and bar tracking foo, then when I run 'git rpull' in bar, it
pulls master, foo, then bar.

This command is most useful when combined with the
'branch.autosetupmerge' configuration variable set to 'always'.

--
q,quiet    Supress the checkout and pull messages.
prune      Remove empty branches from the chain after pulling.
local      Don't fetch from the remotes, just update the local branches.
"

. git-sh-setup

quiet_flags=
prune=0
loc=0
while test $# != 0
do
    case "$1" in
        -q|--quiet)
            quiet_flags="$1"
            ;;
        --prune)
            prune=1
            ;;
        --local)
            loc=1
            ;;
        --)
            shift
            break
            ;;
    esac
    shift
done
test $# != 0 && usage

declare -a branch_chain

# Walk the chain of upstream branches, filling the branch_chain array
# depth-first. The return value is the number of upstream changes. The
# branch is only added to the chain if there are upstream changes (or
# we are pruning), that way there is a minimal impact on the
# work-tree.
fill_branch_chain() {
    eval $(git for-each-ref --shell --format='
local ref=%(refname:short)
local upstream=%(upstream:short)
local fullupstream=%(upstream)' "$1")
    [[ -n $ref ]] || die $1 is not a valid ref

    # If it has no remote, it is unchanged
    local remote=$(git config branch.$ref.remote) && [[ -n $remote ]] || {
        return 0
    }

    # Tracking a local branch, recurse
    local upstreamchanges=0
    if [[ $remote == . ]] ; then
        fill_branch_chain $fullupstream
        upstreamchanges=$?
    else
        if [[ $loc == 0 ]] ; then
            git fetch $quiet_flags $remote
        fi
    fi

    # Tracking a remote branch. Fetch and count the changes.
    local mychanges=$(( upstreamchanges + $(git rev-list $upstream'^{commit}' --not $ref'^{commit}' | wc -l) ))
    (( mychanges == 0 && ! prune )) || branch_chain+=($ref)
    return $mychanges
}

fill_branch_chain $(git symbolic-ref HEAD)
changes=$?

# No changes, nothing to be done.
[[ ${#branch_chain[*]} == 0 ]] && exit 0

require_clean_work_tree "recursively pull $changes commits"

prune_branch() {
    local fullref=$(git symbolic-ref HEAD)
    eval $(git for-each-ref --shell --format='
local upstream=%(upstream)
local upstreamshort=%(upstream:short)
local ref=%(refname:short)' $fullref)

    # We only prune branches that track local branches
    [[ $(git config branch.$ref.remote) == . ]] || return

    # See if we have the same contents as the upstream branch
    local sha=$(git rev-parse $fullref) upsha=$(git rev-parse $upstream)
    if [[ $sha == $upsha ]] ; then
        # Find all the branches that have this ref as the upstream ref and update them
        for branch in $(
            git for-each-ref --format='%(upstream) %(refname:short)' refs/heads/ |
            sed -n -e "s#^$fullref ##p")
        do
            [[ $(git config branch.$branch.remote) == . ]] || continue
            git config branch.$branch.merge $upstream
        done
        git checkout --quiet $upstreamshort -- || exit $?
        git branch -d $ref || exit $?
    fi
}

# Checkout each branch and pull
for branch in "${branch_chain[@]}" ; do
    git checkout $quiet_flags $branch -- || exit $?
    [[ -z $(git config branch.$branch.remote) ]] || git pull $quiet_flags || exit $?
    if (( $prune )) ; then
        prune_branch
    fi
done
