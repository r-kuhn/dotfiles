#! /bin/bash
SUBDIRECTORY_OK=true
OPTIONS_SPEC="\
git rpull [options]

Follow the chain of local tracking branches until a remote tracking
branch is reached, then 'git pull' in each branch on the way back up
to the starting branch.

This lets you quickly bring an entire chain of working branches up to
date with the remote quickly.

--
fetch    Fetch from the upstream remote. This is the default, use --no-fetch to disable it.
q,quiet  Pass --quiet to all fetch, pull, and checkout commands.
"
. git-sh-setup

set -euo pipefail

quiet=
fetch=true
while [[ $1 != -- ]] ; do
    case "$1" in
        --fetch)
            fetch=true
            ;;
        --no-fetch)
            fetch=false
            ;;
        --no-quiet)
            [[ $quiet != -v ]] || set -x
            quiet=-v
            GIT_QUIET=
            ;;
        -q)
            quiet=-q
            GIT_QUIET=-q
            ;;
    esac
    shift
done
shift

[[ $# == 0 ]] || die "unexpected arguments: $*"

real_name() {
    git rev-parse --symbolic-full-name $1
}
short_name() {
    git for-each-ref --format='%(refname:short)' $1
}
upstream() {
    git for-each-ref --format='%(upstream:short)' $(real_name $1)
}
remote_of() {
    git config branch.$1.remote
}

original_branch=$(short_name $(real_name HEAD))

# Derive the chain of tracking refs and determine the remote of the
# last branch (head) in the ref chain -- not the last tracked ref
# though, that is the remote tracking ref (updated by 'git fetch').
branch=$original_branch
upstream_branches=()
remote=$(remote_of $original_branch)
while [[ $remote == . ]] ; do
    branch=$(upstream $branch)
    upstream_branches+=( $branch )
    remote=$(remote_of $branch)
done
upstream_branches+=( $(upstream $branch) )
unset branch

announce() {
    say "#" "$@"
    "$@"
}

if [[ -n $remote && $fetch == true ]] ; then
    announce git fetch $quiet $remote
fi

# If there is nothing to update, bail now before we run any 'git
# checkout' commands and unneccissarily touch the work-tree.
new_changes=$(( $( git rev-list ${upstream_branches[@]} --not $original_branch -- | wc -l ) ))
(( new_changes > 0 )) || exit 0

# Ok, here we go. We need a clean work tree to do this.
require_clean_work_tree "Recursivly pull $new_changes changes" "Commit or stash and try again"

pull_upstream() {
    # Base case: less than two arguments left. The last named ref is
    # the remote tracking branch which was updated by the prior 'git
    # fetch' command, so it doesn't need to be pulled.
    if [[ -n $1 && -n ${2:-} ]] ; then

        # Inductive case: pull our upstream branch first
        local branch=$1
        local upstream=$2
        shift
        pull_upstream $@

        # Postfix: checkout the branch and pull (minus the fetch).
        announce git checkout $quiet $branch
        if [[ $(git config --bool branch.$branch.rebase) == true ]] ; then
            announce git rebase $quiet $upstream
        else
            announce git merge $quiet $upstream
        fi
    fi
}

pull_upstream $original_branch ${upstream_branches[@]}
